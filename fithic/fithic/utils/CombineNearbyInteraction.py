#!/usr/bin/env python

"""
Combines nearby interactions generated by FitHiChIP
by a connected component labeling algorithm


Timeline
----------
November 2017: Creation of the first draft
Feb 2018: Modification to incorporate window size and top K% filtering
July 2018: Fixed the K (=100) and window size (2X2), for 5 Kb bin size
Nov 2018: Added support for different columns of q-value, p-value, contact count, and also provided support for increasing or decreasing order of sorting, to make it applicable for a wide range of significance values.
Jan 2019: Convert to python3
Feb 2019: Rewrite logic


Author: Sourya Bhattacharyya
Vijay-Ay lab, LJI
"""

import os
import sys
import math
#from optparse import OptionParser
import argparse
import networkx as nx
#from queue import heapq
import gzip
import heapq

#==========================================================
# this function returns the element below which top K % of 
# all the elements reside
# lst: input list, K: top K percent
# order: 1 means increasing order sort, 2 means reverse order sort
def custom_percent(lst, K, order=1):
    if (order == 1):
        sortedLst = sorted(lst)
    else:
        sortedLst = sorted(lst, reverse=True)
    lstLen = len(lst)
    index = int(((len(lst) * K) / 100))
    # for very small list, return the minimum 
    if (index <= 1):
        # return ((sum(sortedLst) * 1.0) / len(sortedLst))
        if (order == 1):
            return max(sortedLst)
        else:
            return min(sortedLst)

    return sortedLst[index]

# #==========================================================
# def custom_median(lst):
#     sortedLst = sorted(lst)
#     lstLen = len(lst)
#     index = (lstLen - 1) // 2
#     if (lstLen % 2):
#         return sortedLst[index]
#     else:
#         return (sortedLst[index] + sortedLst[index + 1])/2.0

#==========================================================
""" 
this class defines a particular interaction
the key is (x,y) where x and y are the bin number (x < y)
"""
class Interaction(object):  
    def __init__(self, cc, pval, qval):
        self.contact = cc
        self.PValue = pval
        self.QValue = qval

    def _GetCC(self):
        return self.contact

    def _GetPVal(self):
        return self.PValue

    def _GetQVal(self, count=1):
        return self.QValue
#===============================================
def parse_args(args):
    parser = argparse.ArgumentParser(description="Check the help flag")
    parser.add_argument("-i", "--InpFile", help="Input gzipped interaction Fit-Hi-C output file.", required=True)
    parser.add_argument("-H", "--headerInp", dest="headerInp", type=int, help="If 1, indicates that input interaction file has a header line (such as field names). Default 1.", default=1)
    parser.add_argument("-o", "--OutFile", help="Output merged gzipped interaction file.", required=True)
    parser.add_argument("-r", "--resolution", help="Resolution of Fit-Hi-C run.", required=True)
    parser.add_argument("-c", "--conn", help="Rule of connectivity (8 or 4). Default is 8.", required=False, default=8, type=int, dest="connectivity_rule")

    # q-value threshold considered for interactions
    # only loops having q-value below this threshold are considered
    # sourya - do not use this threshold
    # parser.add_argument("-q", "--qvalue_threshold", type=float, help="Q-value threshold to utilize for significant interactions. Default is 1e-5", default=(10**-5))

    parser.add_argument("-p", "--percent", dest="TopPctElem", type=int, help="Percentage of elements to be selected from each connected component. Default: 100, means all loops would be considered. If specified as 0, only the most significant loops from each component would be selected. For any number x between 0 and 100, top x%% of the loops in a component, considering both statistical significance and contact count, would considered for inclusion, subject to the bin and neighborhood contraints.", default=100)
    
    parser.add_argument("-n", "--Neigh", dest="NeighborHoodBin", type=int, help="Positive integer (default: 2 with 5 Kb bin size) means that if a loop is included in the final set, loops involving within 2x2 neighborhood of both the bins would be discarded. Applicable only if --percent > 0. Difference in bin size other than 5000 may prompt user to change this value.", default=2)
    
    parser.add_argument("-s","--order", dest="SortOrder", type=int, help="Binary variable indicating the sorting order of the given significance values. Default 0, means sorting is done by ascending order. If specified 1, sorting is done by descending (reverse) order.", default=0)
    
    #parser.add_argument("--cccol", dest="CCCol", type=int, help="Column number storing the contact count. Default: 7.", default=7)

    #parser.add_argument("--qcol", dest="QValCol", type=int, help="Column number storing the q-value (or any measure of statistical significance). Default: 0, means the last column of the given interaction file. Any non-zero value would prompt the user to check the corresponding column.", default=0)
    #parser.add_argument("--pcol", dest="PValCol", type=int, help="Column number storing the p-value (or any measure of statistical significance). Default: 0, means the second last column of the given interaction file. Any non-zero value would prompt the user to check the corresponding column.", default=0)

    return parser.parse_args()

#===============================================
def main():
    options = parse_args(sys.argv[1:])

    #===========================
    # process the input parameters
    #===========================
    if options.InpFile is not None:
        InpFile = options.InpFile
    else:
        sys.exit("Input file is not provided - quit !!")

    # output file storing the bed formatted interactions
    if options.OutFile is not None:
        OutFile = options.OutFile
    else:
        sys.exit("Output file is not specified - quit !!")

    # bin size of FitHiC loops - mandatory parameter 
    bin_size = int(options.resolution)

    # presence of header in input file
    headerInp = int(options.headerInp)  #1

    # q-value threshold for considering interactions for merging
    # should not be used - sourya
    # qvalue_threshold = float(options.qvalue_threshold)
    
    connectivity_rule = int(options.connectivity_rule)
    TopPctElem = int(options.TopPctElem)
    NeighborHoodBinThr = (int(options.NeighborHoodBin)) * bin_size

    # parameters regarding significance and sorting order of statistical significance values
    #QValCol=int(options.QValCol)
    QValCol = 7
    #PValCol=int(options.PValCol)
    PValCol = 6
    #CCCol=int(options.CCCol)
    CCCol = 5
    SortOrder=int(options.SortOrder)

    # according to the input file being normal file or gzipped file, set the following variable
    if InpFile.endswith(".gz"):
        gzip_inp = True
    else:
        gzip_inp = False

    # #====================
    # # fix the columns containing P and Q-values
    # # by reading the first line of the input interaction file
    # if InpFile.endswith(".gz"):
    #     fp_in = gzip.open(InpFile, 'rt')
    # else:
    #     fp_in = open(InpFile, 'rt')

    # l = fp_in.readline()
    # contents = l.rstrip().split()
    # if (QValCol == 0):
    #     QValCol = len(contents)
    # if (PValCol == 0):
    #     PValCol = (len(contents) - 1)
    # fp_in.close()
    #====================

    # print the parameters
    if 1:
        print('\n *** bin_size: ', bin_size)
        print('\n *** headerInp: ', headerInp)
        print('\n *** connectivity_rule: ', connectivity_rule)
        print('\n *** TopPctElem: ', TopPctElem)
        print('\n *** NeighborHoodBinThr: ', NeighborHoodBinThr)
        print('\n *** QValCol: ', QValCol)
        print('\n *** PValCol: ', PValCol)
        print('\n *** SortOrder: ', SortOrder)
    
    # output directory
    OutDir = os.path.dirname(os.path.realpath(OutFile))
    if not os.path.exists(OutDir):
        os.makedirs(OutDir)
    if 1:
        print('OutDir: ', str(OutDir))

    #====================
    # generate a file containing the list of chromosomes in the current file
    #====================
    t = os.path.basename(os.path.realpath(OutFile))
    # temp_ChrName_File = OutDir + '/' + t[0:(t.rfind('.')-1)] + '_chrName.bed'
    temp_ChrName_File = OutDir + '/' + t[0:t.rfind('.')] + '_chrName.bed'
    print('temp_ChrName_File: ', str(temp_ChrName_File))
    if (gzip_inp == 1):
        if (headerInp == 1):
            currcmd = "zcat " + str(InpFile) + "| awk \'{if (NR>1) {print $1}}\' - | sort -k1,1 | uniq > " + str(temp_ChrName_File)
        else:
            currcmd = "zcat " + str(InpFile) + "| cut -f1 | sort -k1,1 | uniq > " + str(temp_ChrName_File)
    else:
        if (headerInp == 1):
            currcmd = "cat " + str(InpFile) + "| awk \'{if (NR>1) {print $1}}\' - | sort -k1,1 | uniq > " + str(temp_ChrName_File)
        else:
            currcmd = "cat " + str(InpFile) + "| cut -f1 | sort -k1,1 | uniq > " + str(temp_ChrName_File)
    os.system(currcmd)

    #====================
    # now read the file containing the list of chromosomes 
    # and store it in a structure
    #====================
    # list of chromosomes to be experimented
    TargetChrList = []
    # for i in range(1, 23):
    #     curr_chr = 'chr' + str(i)
    #     TargetChrList.append(curr_chr)
    # TargetChrList.append('chrX')
    # TargetChrList.append('chrY')
    
    chrp_in = open(temp_ChrName_File, 'r')
    while True:
        l = chrp_in.readline()
        if not l: 
            break
        contents = l.rstrip().split()
        TargetChrList.append(contents[0])
    chrp_in.close()

    # print the input chromosome list
    print('List of chromosomes considered: ', str(TargetChrList))

    #======================
    # open the output file
    #======================
    # dump the header in the output file as well
    # comment - sourya
    # add - sourya
    #fp_outInt = open(OutFile, 'wt')
    fp_outInt = gzip.open(OutFile, 'wt')
    #fp_outInt.write('chr1' + '\t' + 'start1' + '\t' + 'end1' + '\t' + 'chr2' + '\t' + 'start2' + '\t' + 'end2' + '\t' + 'CC' + '\t' + 'p' + '\t' + 'fdr' + '\t' + 'bin1_low' + '\t' + 'bin1_high' + '\t' + 'bin2_low' + '\t' + 'bin2_high' + '\t' + 'sumCC' + '\t' + 'StrongConn')
    fp_outInt.write('chr1' + '\t' + 'mid1' + '\t' + 'chr2' + '\t' + 'mid2'  + '\t' + 'CC' + '\t' + 'p' + '\t' + 'fdr' + '\t' + 'bin1_low' + '\t' + 'bin1_high' + '\t' + 'bin2_low' + '\t' + 'bin2_high' + '\t' + 'sumCC' + '\t' + 'StrongConn')

    #=========================================
    # loop to process individual chromosomes and corresponding data
    #=========================================
    for chridx in range(len(TargetChrList)):
        curr_chr = TargetChrList[chridx]
        if 1:
            print('Processing the chromosome: ', str(curr_chr))

        # extract the interactions of current chromosome from the complete set of interactions
        # file names are provided according to the chromosome name
        tempchrdumpfile = OutDir + '/Temp_' + str(curr_chr) + '_Dump.bed'
        if (headerInp == 1):
            if (gzip_inp == 1):
                # comment - sourya
                # uses q-value threshold
                # awkcmd = "zcat " + str(InpFile) + " | awk \'{if (NR>1 && $1==\"" + str(curr_chr) + "\" && $3==\"" + str(curr_chr) + "\" && $7 <=" + str(qvalue_threshold) + "){print $0}}\' -  > " + str(tempchrdumpfile)
                # modification - sourya
                # just dump the significant loops for this chromosome
                awkcmd = "zcat " + str(InpFile) + " | awk \'{if (NR>1 && $1==\"" + str(curr_chr) + "\" && $3==\"" + str(curr_chr) + "\"){print $0}}\' -  > " + str(tempchrdumpfile)
            else:
                awkcmd = "cat " + str(InpFile) + " | awk \'{if (NR>1 && $1==\"" + str(curr_chr) + "\" && $3==\"" + str(curr_chr) + "\"){print $0}}\' -  > " + str(tempchrdumpfile)
        else:
            if (gzip_inp == 1):
                awkcmd = "zcat " + str(InpFile) + " | awk \'{if ($1==\"" + str(curr_chr) + "\" && $3==\"" + str(curr_chr) + "\"){print $0}}\' -  > " + str(tempchrdumpfile)
            else:
                awkcmd = "cat " + str(InpFile) + " | awk \'{if ($1==\"" + str(curr_chr) + "\" && $3==\"" + str(curr_chr) + "\"){print $0}}\' -  > " + str(tempchrdumpfile)

        print(awkcmd)
        os.system(awkcmd)

        # check the number of dumped interactions
        num_Int = sum(1 for line in open(tempchrdumpfile))
        print('Number of interactions for the current chromosome: ', str(num_Int))

        if (num_Int == 0):
            if 0:
                print('Number of interactions for this chromosome = 0 --- continue')
            continue

        if 1:
            print('Extracted interactions for the current chromosome')

        #==========================
        # Graph modeling for the current chromosome
        #==========================
        # create a graph which will store the interactions
        G = nx.Graph()

        # create a dictionary for storing the interactions
        CurrChrDict = dict()

        # now scan through the interactions of the extracted chromosome 
        # and create a dictionary whose keys are the interacting bin numbers
        with open(tempchrdumpfile, 'r') as fp:
            for line in fp:
                linecontents = (line.rstrip()).split()
                # we set the bin number according to the end coordinate
                bin1 = int(float(linecontents[1])+(bin_size/2)) / bin_size
                #bin1 = int(linecontents[2]) / bin_size
                bin2 = int(float(linecontents[3])+(bin_size/2)) / bin_size
                #bin2 = int(linecontents[5]) / bin_size
                if (bin1 < bin2):
                    curr_key = (bin1, bin2)
                else:
                    curr_key = (bin2, bin1)
                # assign the key to the dictionary
                # add the contact count, P value and Q value information as well
                CurrChrDict.setdefault(curr_key, Interaction(int(linecontents[CCCol-1]), float(linecontents[PValCol - 1]), float(linecontents[QValCol - 1])))
                # add the node to the given graph as well
                G.add_node(curr_key)
                if 0:
                    print('Current interaction: ', str(line), '  ------ curr_key: ', curr_key)

        # now check the nodes of G
        # assign edges of G according to the 8 / 4 connectivity rule (according to the input parameter)
        nodelist = list(G.nodes())

        for i in range(len(nodelist) - 1):
            node1 = nodelist[i]
            for j in range(i+1, len(nodelist)):
                node2 = nodelist[j]
                if 0:
                    print('Checking the edge between node 1: ', node1, '  and node 2: ', node2)
                # check if there should be an edge between node1 and node2
                # according to the desired connectivity rule
                if (connectivity_rule == 8):
                    if (abs(node1[0] - node2[0]) <= 1) and (abs(node1[1] - node2[1]) <= 1):
                        G.add_edge(node1, node2)
                        if 0:
                            print('8 connectivity Edge between node 1: ', node1, '  and node 2: ', node2)
                if (connectivity_rule == 4):
                    if ((abs(node1[0] - node2[0]) + abs(node1[1] - node2[1])) <= 1):
                        G.add_edge(node1, node2)
                        if 0:
                            print('4 connectivity Edge between node 1: ', node1, '  and node 2: ', node2)

        # check the edges of G
        edgelist = list(G.edges())

        if 1:
            print('No of nodes of G: ', G.number_of_nodes())
            print('No of edges of G: ', G.number_of_edges())
            print('Number of connected components of G: ', nx.number_connected_components(G))

        # scan through individual connected components
        # for each such connected component (list of interactions)
        # we find a representative interaction and print it in the final output file
        list_conn_comp = sorted(nx.connected_components(G), key = len, reverse=True)

        if 1:
            print('\n\n**** Number of connected components: ', len(list_conn_comp), '  ****\n\n')

        #====================
        # process individual connected components
        #====================
        for i in range(len(list_conn_comp)):
            # a connected component - a particular list of connected nodes
            curr_comp_list = list(list_conn_comp[i])
            if 1:
                print('\n\n\n  ===>>>>> Processing the connected component no: ', i, '  list: ', str(curr_comp_list), '  number of elements: ', len(curr_comp_list))

            # from the first interacting bin set, get the lower and higher bin index
            min_idx_bin1 = int(min([x[0] for x in curr_comp_list]))
            max_idx_bin1 = int(max([x[0] for x in curr_comp_list]))
            if 1:
                print('min_idx_bin1: ', min_idx_bin1, ' max_idx_bin1: ', max_idx_bin1)

            # get the span of coordinates for the first interacting bin (set)
            span_low_bin1 = (min_idx_bin1 - 1) * bin_size
            span_high_bin1 = max_idx_bin1 * bin_size
            if 1:
                print('span_low_bin1: ', span_low_bin1, ' span_high_bin1: ', span_high_bin1)

            # from the second interacting bin set, get the lower and higher bin index
            min_idx_bin2 = int(min([x[1] for x in curr_comp_list]))
            max_idx_bin2 = int(max([x[1] for x in curr_comp_list]))
            if 1:
                print('min_idx_bin2: ', min_idx_bin2, ' max_idx_bin2: ', max_idx_bin2)

            # get the span of coordinates for the first interacting bin (set)
            span_low_bin2 = (min_idx_bin2 - 1) * bin_size
            span_high_bin2 = max_idx_bin2 * bin_size
            if 1:
                print('span_low_bin2: ', span_low_bin2, ' span_high_bin2: ', span_high_bin2)

            # sum of contact counts for all the interacting bins 
            # within this set of connected nodes
            sum_cc = sum([CurrChrDict[x]._GetCC() for x in curr_comp_list])

            # now get the percentage of bin pairs within this set of connected component
            # having a significant interaction
            total_possible_bin_pairs = (max_idx_bin1 - min_idx_bin1 + 1) * (max_idx_bin2 - min_idx_bin2 + 1)
            possible_bin_pairs = 0
            for b1 in range(min_idx_bin1, (max_idx_bin1 + 1)):
                for b2 in range(min_idx_bin2, (max_idx_bin2 + 1)):
                    bin_pair_key = (b1, b2)
                    if bin_pair_key in CurrChrDict:
                        possible_bin_pairs = possible_bin_pairs + 1
            
            # % of bin pairs within the region spanned by this connected component
            # having significant interaction
            # the higher the %, the better this component is strongly connected
            Percent_Significant_BinPair = (possible_bin_pairs * 1.0) / total_possible_bin_pairs

            if 1:
                print(' ==>>> total_possible_bin_pairs: ', total_possible_bin_pairs, ' possible_bin_pairs: ', possible_bin_pairs, ' % clique: ', Percent_Significant_BinPair)

            #==================================================
            # approach 1 : 
            # if TopPctElem = 0 then 
            # get the bin having maximum statistical significance and corresponding bin pairs
            # ties are resolved by maximum contact count
            # if SortOrder = 0, maximum statistical significance === min P and Q values
            # if SortOrder = 1, maximum statistical significance === max P and Q (equivalent) measures
            #==================================================
            if (TopPctElem == 0):

                for j in range(len(curr_comp_list)):
                    curr_key = curr_comp_list[j]
                    curr_cc = CurrChrDict[curr_key]._GetCC()
                    curr_pval = CurrChrDict[curr_key]._GetPVal()
                    curr_qval = CurrChrDict[curr_key]._GetQVal()
                    
                    curr_key_bin1_mid = (((curr_key[0] - 1) * bin_size) + (curr_key[0] * bin_size)) / 2
                    curr_key_bin2_mid = (((curr_key[1] - 1) * bin_size) + (curr_key[1] * bin_size)) / 2
                    if 0:
                        print(' Connected component index: ', j, ' curr_key: ', curr_key, ' bin 1 mid: ', curr_key_bin1_mid, ' bin 2 mid: ', curr_key_bin2_mid, ' CC: ', curr_cc, ' Pval: ', curr_pval, ' Qval: ', curr_qval)
                    if (j == 0):
                        # first index
                        rep_bin_key = curr_key                        
                    elif (SortOrder == 0) and (curr_pval < CurrChrDict[rep_bin_key]._GetPVal()) and (curr_qval < CurrChrDict[rep_bin_key]._GetQVal()):
                        # current element has higher statistical significance (lower P or Q value when SortOrder = 0)
                        rep_bin_key = curr_key
                    elif (SortOrder == 1) and (curr_pval > CurrChrDict[rep_bin_key]._GetPVal()) and (curr_qval > CurrChrDict[rep_bin_key]._GetQVal()):
                        # current element has higher statistical significance (higher P or Q value when SortOrder = 1)
                        rep_bin_key = curr_key
                    elif (curr_pval == CurrChrDict[rep_bin_key]._GetPVal()) and (curr_qval == CurrChrDict[rep_bin_key]._GetQVal()) and (curr_cc > CurrChrDict[rep_bin_key]._GetCC()):
                        # current element has equal P and Q values
                        # but higher contact count
                        rep_bin_key = curr_key

                # fix the representative interaction
                rep_bin1_low = (rep_bin_key[0] - 1) * bin_size
                rep_bin1_high = rep_bin_key[0] * bin_size
                rep_bin2_low = (rep_bin_key[1] - 1) * bin_size
                rep_bin2_high = rep_bin_key[1] * bin_size
                cc = CurrChrDict[rep_bin_key]._GetCC()
                pval = CurrChrDict[rep_bin_key]._GetPVal()
                qval = CurrChrDict[rep_bin_key]._GetQVal()

                if 1:
                    print('**** Selected bin key: ', rep_bin_key, ' start bin mid: ', (rep_bin1_low + rep_bin1_high)/2,  ' end bin mid: ', (rep_bin2_low + rep_bin2_high) / 2, ' cc: ', cc, ' pval: ', pval, ' qval: ', qval)

                # write the interaction in the specified output file
                #fp_outInt.write('\n' + str(curr_chr) + '\t' + str(rep_bin1_low) + '\t' + str(rep_bin1_high) + '\t' + str(curr_chr) + '\t' + str(rep_bin2_low) + '\t' + str(rep_bin2_high) + '\t' + str(cc) + '\t' + str(pval) + '\t' + str(qval) + '\t' + str(span_low_bin1) + '\t' + str(span_high_bin1) + '\t' + str(span_low_bin2) + '\t' + str(span_high_bin2) + '\t' + str(sum_cc) + '\t' + str(Percent_Significant_BinPair))
                fp_outInt.write('\n' + str(curr_chr) + '\t' + str((rep_bin1_low + rep_bin1_high)/2) + '\t' + str(curr_chr) + '\t' + str((rep_bin2_low + rep_bin2_high)/2) + '\t' + str(cc) + '\t' + str(pval) + '\t' + str(qval) + '\t' + str(span_low_bin1) + '\t' + str(span_high_bin1) + '\t' + str(span_low_bin2) + '\t' + str(span_high_bin2) + '\t' + str(sum_cc) + '\t' + str(Percent_Significant_BinPair))
            
            #==================================================
            # approach 2: 
            # if TopPctElem > 0, and TopPctElem < 100
            # then get the top (TopPctElem %) elements from 
            # each connected component, (P and Q values, contact counts)
            # use these elements if they satisfy the bin neighborhood threshold
            #==================================================
            if (TopPctElem > 0) and (TopPctElem < 100):

                # list to store the q-values and the CC values for individual bin pairs
                # for their sequential extraction
                Curr_Comp_Tuple_List = []

                # lists storing different attributes
                curr_conn_comp_CCList = []
                curr_conn_comp_QValList = []

                # process individual elements within this connected component
                for j in range(len(curr_comp_list)):
                    curr_key = curr_comp_list[j]
                    curr_cc = CurrChrDict[curr_key]._GetCC()
                    curr_pval = CurrChrDict[curr_key]._GetPVal()
                    curr_qval = CurrChrDict[curr_key]._GetQVal()
                    curr_conn_comp_CCList.append(curr_cc)
                    curr_conn_comp_QValList.append(curr_qval)

                    # create a min-heap structure
                    # first element: q-value 
                    # if SortOrder = 0, lower: better: use the same sign when insering in the heap
                    # if SortOrder = 1, higher: better: reverse the sign when insering in the heap
                    # for ties, second element (contact count) - higher: better
                    # so, use negative signs 
                    if (SortOrder == 0):
                        subl = [curr_qval, ((-1) * curr_cc), curr_key[0], curr_key[1]]
                    else:
                        subl = [((-1) * curr_qval), ((-1) * curr_cc), curr_key[0], curr_key[1]]

                    # insert the element in the designated queue
                    heapq.heappush(Curr_Comp_Tuple_List, subl)

                # first get the maximum / minimum values from these lists
                max_cc = max(curr_conn_comp_CCList)
                min_qval = min(curr_conn_comp_QValList)
                
                # now obtain the values of top K % elements
                # from these lists
                # where K = 50 means it is median
                custom_cc = custom_percent(curr_conn_comp_CCList, TopPctElem, 2)
                custom_qval = custom_percent(curr_conn_comp_QValList, TopPctElem, (SortOrder+1))

                if 0:
                    print(' --> current connected component: max CC: ', max_cc, '  min Q val: ', min_qval, '  top K (TopPctElem): ', TopPctElem, '  custom_cc threshold: ', custom_cc, '  custom_qval threshold: ', custom_qval)

                # this list stores the candidate interactions
                # from this particular connected component
                # that will be used in the final set of interactions
                Final_Rep_Key_List = []

                # now extract elements from the constructed queue
                while (len(Curr_Comp_Tuple_List) > 0):
                    curr_elem = heapq.heappop(Curr_Comp_Tuple_List)
                    if 0:
                        print('extracted element from heap: ', curr_elem)

                    #===================================
                    # earlier condition - 1 - sourya
                    # consider only those interactions
                    # which have sufficient values of both contact count
                    # and q-values
                    
                    # # terminating condition - do not consider elements 
                    # # with lower log 10 Q values than the custom_logqval
                    # if ((curr_elem[0] * (-1)) < custom_logqval):
                    #     break

                    # # coninue if the contact count falls below the designated threshold
                    # if ((curr_elem[1] * (-1)) < custom_cc):
                    #     continue
                    #===================================
                    # modified condition - sourya
                    # consider those interactions having 
                    # significance value > K percentile
                    if ((SortOrder == 0) and (curr_elem[0] > custom_qval)) or ((SortOrder == 1) and (curr_elem[0] < custom_qval)):
                        break
                    #===================================

                    # if this is the first element 
                    # then insert they key in the candidate set of interactions
                    if (len(Final_Rep_Key_List) == 0):
                        subl = [curr_elem[2], curr_elem[3]]
                        Final_Rep_Key_List.append(subl)
                        if 0:
                            print('\t\t *** inserted element in the final list: ', str(subl), '  generated Final_Rep_Key_List: ', str(Final_Rep_Key_List))
                        continue

                    # otherwise, check with the existing interactions
                    # and do not include if the bin falls within a certain 
                    # neighborhood of earlier included interactions
                    # the neighborhood is already mentioned via command line parameters
                    flag = False
                    for i in range(len(Final_Rep_Key_List)):
                        # both ends of the bins should be within neighborhood thresholds
                        # of existing contacts
                        if (((abs(Final_Rep_Key_List[i][0] - curr_elem[2])) * bin_size) <= NeighborHoodBinThr) and (((abs(Final_Rep_Key_List[i][1] - curr_elem[3])) * bin_size) <= NeighborHoodBinThr):
                            flag = True
                            if 0:
                                print(' --- current element is within neighborhood of the bins indexed by ', i, '  of Final_Rep_Key_List')
                            break
                    
                    if (flag == False):
                        # there is no such neighborhood constraints
                        # include the bin
                        subl = [curr_elem[2], curr_elem[3]]
                        Final_Rep_Key_List.append(subl)
                        if 0:
                            print('\t\t *** inserted element in the final list: ', str(subl), '  generated Final_Rep_Key_List: ', str(Final_Rep_Key_List))
                        
                # now print the candidate interactions 
                # of the current component
                for i in range(len(Final_Rep_Key_List)):
                    rep_bin_key = (Final_Rep_Key_List[i][0], Final_Rep_Key_List[i][1])
                
                    # fix the representative interaction
                    rep_bin1_low = (rep_bin_key[0] - 1) * bin_size
                    rep_bin1_high = rep_bin_key[0] * bin_size
                    rep_bin2_low = (rep_bin_key[1] - 1) * bin_size
                    rep_bin2_high = rep_bin_key[1] * bin_size
                    cc = CurrChrDict[rep_bin_key]._GetCC()
                    pval = CurrChrDict[rep_bin_key]._GetPVal()
                    qval = CurrChrDict[rep_bin_key]._GetQVal()

                    if 1:
                        print('**** Selected bin key: ', rep_bin_key, ' start bin mid: ', (rep_bin1_low + rep_bin1_high)/2,  ' end bin mid: ', (rep_bin2_low + rep_bin2_high) / 2, ' cc: ', cc, ' pval: ', pval, ' qval: ', qval)
                    
                    # write the interaction in the specified output file
                    # fp_outInt.write('\n' + str(curr_chr) + '\t' + str(rep_bin1_low) + '\t' + str(rep_bin1_high) + '\t' + str(curr_chr) + '\t' + str(rep_bin2_low) + '\t' + str(rep_bin2_high) + '\t' + str(cc) + '\t' + str(pval) + '\t' + str(qval) + '\t' + str(span_low_bin1) + '\t' + str(span_high_bin1) + '\t' + str(span_low_bin2) + '\t' + str(span_high_bin2) + '\t' + str(sum_cc) + '\t' + str(Percent_Significant_BinPair))
                    fp_outInt.write('\n' + str(curr_chr) + '\t' + str((rep_bin1_low + rep_bin1_high)/2) + '\t' + str(curr_chr) + '\t' + str((rep_bin2_low + rep_bin2_high)/2) + '\t' + str(cc) + '\t' + str(pval) + '\t' + str(qval) + '\t' + str(span_low_bin1) + '\t' + str(span_high_bin1) + '\t' + str(span_low_bin2) + '\t' + str(span_high_bin2) + '\t' + str(sum_cc) + '\t' + str(Percent_Significant_BinPair))

            #==================================================
            # approach 3: 
            # if TopPctElem = 100 (latest implementation)
            # then sequentially obtain the interactions with the lowest q-value
            # and break the tie for the higher contact count
            # use these elements if they satisfy the bin neighborhood threshold
            #==================================================
            if (TopPctElem == 100):

                # list to store the q-values and the CC values for individual bin pairs
                # for their sequential extraction
                Curr_Comp_Tuple_List = []
                
                # lists storing different attributes
                curr_conn_comp_CCList = []
                curr_conn_comp_QValList = []

                # process individual elements within this connected component
                for j in range(len(curr_comp_list)):
                    curr_key = curr_comp_list[j]
                    curr_cc = CurrChrDict[curr_key]._GetCC()
                    curr_qval = CurrChrDict[curr_key]._GetQVal()
                    curr_conn_comp_CCList.append(curr_cc)
                    curr_conn_comp_QValList.append(curr_qval)

                    # create a min-heap structure
                    # first element: q-value 
                    # if SortOrder = 0, lower: better: use the same sign when insering in the heap
                    # if SortOrder = 1, higher: better: reverse the sign when insering in the heap
                    # for ties, second element (contact count) - higher: better
                    # so, use negative signs 
                    if (SortOrder == 0):
                        subl = [curr_qval, ((-1) * curr_cc), curr_key[0], curr_key[1]]
                    else:
                        subl = [((-1) * curr_qval), ((-1) * curr_cc), curr_key[0], curr_key[1]]
              
                    # insert the element in the designated queue (min-heap property)
                    heapq.heappush(Curr_Comp_Tuple_List, subl)

                # this list stores the candidate interactions
                # from this particular connected component
                # that will be used in the final set of interactions
                Final_Rep_Key_List = []

                if 1:
                    print(' **** Processing the connected component ===== number of elements: ', len(Curr_Comp_Tuple_List))

                # now extract elements from the constructed queue
                while (len(Curr_Comp_Tuple_List) > 0):
                    # extract the first element from the min-heap
                    # element with the lowest value
                    curr_elem = heapq.heappop(Curr_Comp_Tuple_List)
                    if 0:
                        print('extracted element from heap: ', curr_elem)

                    # if this is the first element 
                    # then insert they key in the candidate set of interactions
                    if (len(Final_Rep_Key_List) == 0):
                        subl = [curr_elem[2], curr_elem[3]]
                        Final_Rep_Key_List.append(subl)
                        if 0:
                            print('*** inserted element in the final list: ', str(subl))
                        continue

                    # otherwise, check with the existing interactions
                    # and do not include if the bin falls within a certain 
                    # neighborhood of earlier included interactions
                    # the neighborhood is already mentioned via command line parameters
                    flag = False
                    for i in range(len(Final_Rep_Key_List)):
                        # both ends of the bins should be within neighborhood thresholds
                        # of existing contacts
                        if (((abs(Final_Rep_Key_List[i][0] - curr_elem[2])) * bin_size) <= NeighborHoodBinThr) and (((abs(Final_Rep_Key_List[i][1] - curr_elem[3])) * bin_size) <= NeighborHoodBinThr):
                            flag = True
                            if 0:
                                print(' --- current element is within neighborhood of the existing (included) bin ', Final_Rep_Key_List[i])
                            break

                    if (flag == False):
                        # there is no such neighborhood constraints
                        # include the bin
                        subl = [curr_elem[2], curr_elem[3]]
                        Final_Rep_Key_List.append(subl)
                        if 0:
                            print('*** inserted element in the final list: ', str(subl))

                # now print the candidate interactions 
                # of the current component
                if 0:
                    print('\n\n**** Printing selected loops of the connected component ***\n\n')

                for i in range(len(Final_Rep_Key_List)):
                    rep_bin_key = (Final_Rep_Key_List[i][0], Final_Rep_Key_List[i][1])
                
                    # fix the representative interaction
                    rep_bin1_low = (rep_bin_key[0] - 1) * bin_size
                    rep_bin1_high = rep_bin_key[0] * bin_size
                    rep_bin2_low = (rep_bin_key[1] - 1) * bin_size
                    rep_bin2_high = rep_bin_key[1] * bin_size
                    cc = CurrChrDict[rep_bin_key]._GetCC()
                    pval = CurrChrDict[rep_bin_key]._GetPVal()
                    qval = CurrChrDict[rep_bin_key]._GetQVal()                    
                    if 1:
                        print('Selected bin key: ', rep_bin_key, ' start bin mid: ', (rep_bin1_low + rep_bin1_high)/2,  ' end bin mid: ', (rep_bin2_low + rep_bin2_high) / 2, ' cc: ', cc, ' pval: ', pval, ' qval: ', qval)

                    # write the interaction in the specified output file
                    # fp_outInt.write('\n' + str(curr_chr) + '\t' + str(rep_bin1_low) + '\t' + str(rep_bin1_high) + '\t' + str(curr_chr) + '\t' + str(rep_bin2_low) + '\t' + str(rep_bin2_high) + '\t' + str(cc) + '\t' + str(pval) + '\t' + str(qval) + '\t' + str(span_low_bin1) + '\t' + str(span_high_bin1) + '\t' + str(span_low_bin2) + '\t' + str(span_high_bin2) + '\t' + str(sum_cc) + '\t' + str(Percent_Significant_BinPair))
                    fp_outInt.write('\n' + str(curr_chr) + '\t' + str((rep_bin1_low + rep_bin1_high)/2) + '\t' + str(curr_chr) + '\t' + str((rep_bin2_low + rep_bin2_high)/2) + '\t' + str(cc) + '\t' + str(pval) + '\t' + str(qval) + '\t' + str(span_low_bin1) + '\t' + str(span_high_bin1) + '\t' + str(span_low_bin2) + '\t' + str(span_high_bin2) + '\t' + str(sum_cc) + '\t' + str(Percent_Significant_BinPair))


            #==================================================

        # remove the temporary chromosome specific interaction dump file
        # in the current iteration
        sys_cmd = "rm " + str(tempchrdumpfile)
        os.system(sys_cmd)

    # after processing all the chromosomes, now close the output interaction file
    fp_outInt.close()

    # # remove the temp log file which stores the max coordinate for a chromosome
    # sys_cmd = "rm " + str(temp_log_file)
    # os.system(sys_cmd)

    if 1:
        print('End of merging filtering loops !!! ')

#===============================================
if __name__ == "__main__":
    main()

